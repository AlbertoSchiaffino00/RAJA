<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RAJA Tutorial and Examples &mdash; RAJA 2022.03.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Basic Loop Execution: Vector Addition" href="tutorial/add_vectors.html" />
    <link rel="prev" title="Application Considerations" href="app_considerations.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> RAJA
            <img src="../../_static/RAJA_LOGO_CMYK_White_Background_large.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2022.03
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">RAJA User Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="getting_started.html">Getting Started With RAJA</a></li>
<li class="toctree-l2"><a class="reference internal" href="using_raja.html">Using RAJA in Your Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="config_options.html">Build Configuration Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html">RAJA Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="app_considerations.html">Application Considerations</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">RAJA Tutorial and Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#raja-tutorial">RAJA Tutorial</a></li>
<li class="toctree-l3"><a class="reference internal" href="#a-little-c-background">A Little C++ Background</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#c-templates">C++ Templates</a></li>
<li class="toctree-l4"><a class="reference internal" href="#elements-of-c-lambda-expressions">Elements of C++ Lambda Expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#a-few-notes-about-lambda-usage-with-raja">A Few Notes About Lambda Usage With RAJA</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#raja-examples-and-exercises">RAJA Examples and Exercises</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-loops-and-basic-raja-features">Simple Loops and Basic RAJA Features</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tutorial/add_vectors.html">Basic Loop Execution: Vector Addition</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/indexset_segments.html">Iteration Spaces: Segments and IndexSets</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/vertexsum_coloring.html">Iteration Space Coloring: Mesh Vertex Sum</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/dot_product.html">Sum Reduction: Vector Dot Product</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/reductions.html">Reduction Types and Kernels with Multiple Reductions</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/atomic_histogram.html">Atomic Operations: Computing a Histogram</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/scan.html">Parallel Scan Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/sort.html">Parallel Sort Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/view_layout.html">Data Views and Layouts</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/permuted-layout-batch-matrix-multiply.html">Permuted Layout: Batched Matrix-Multiplication</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#complex-loops-and-advanced-raja-features">Complex Loops and Advanced RAJA Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nested-loops-with-raja-kernel">Nested Loops with <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="tutorial/kernel_nested_loop_reorder.html">Basic <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> Mechanics and Nested Loop Ordering</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/kernel_exec_pols.html"><code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> Execution Policies</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/offset-layout-5pt-stencil.html">OffsetLayout: Five-point Stencil</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#nested-loops-with-raja-expt-launch">Nested Loops with <code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="tutorial/launch_basic.html"><code class="docutils literal notranslate"><span class="pre">RAJA::expt::Launch</span></code> Basics</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/launch_exec_pols.html"><code class="docutils literal notranslate"><span class="pre">RAJA::expt::Launch</span></code> Execution Policies</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/launch_naming_kernels.html">Naming kernels for NVTX/ROCTX tools</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comparing-raja-kernel-and-raja-expt-launch-matrix-transpose">Comparing <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> and <code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code>: Matrix-Transpose</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tutorial/matrix_transpose.html">Matrix Transpose</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/matrix_transpose_tiled.html">Tiled Matrix Transpose</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/matrix_transpose_local_array.html">Tiled Matrix Transpose with Local Array</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#other-raja-features-and-usage-examples">Other RAJA Features and Usage Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tutorial/halo-exchange.html">Workgroup Constructs: Halo Exchange</a></li>
<li class="toctree-l4"><a class="reference internal" href="tutorial/matrix_multiply.html">Matrix Multiplication: RAJA::kernel</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide/index.html">RAJA Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../raja_license.html">RAJA Copyright and License Information</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">RAJA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">RAJA User Guide</a> &raquo;</li>
      <li>RAJA Tutorial and Examples</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/sphinx/user_guide/tutorial.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="raja-tutorial-and-examples">
<span id="tutorial-label"></span><h1>RAJA Tutorial and Examples<a class="headerlink" href="#raja-tutorial-and-examples" title="Permalink to this headline">Â¶</a></h1>
<p>The following sections contain tutorial material and examples that describe
how to use RAJA features.</p>
<section id="raja-tutorial">
<h2>RAJA Tutorial<a class="headerlink" href="#raja-tutorial" title="Permalink to this headline">Â¶</a></h2>
<p>This section contains a self-paced tutorial that shows how to use many RAJA
features by way of a sequence of examples and exercises. Each exercise is
located in files in the <code class="docutils literal notranslate"><span class="pre">RAJA/exercises</span></code> directory, one <em>exercise</em> file with
code sections removed and comments containing instructions to fill in the
missing code parts and one <em>solution</em> file containing complete working code to
compare with and for guidance if you get stuck working on the exercise file.
You are encouraged to build and run the exercises and modify them to try out
different variations.</p>
<p>We also maintain a repository of tutorial slide presentations
<a class="reference external" href="https://github.com/LLNL/RAJA-tutorials">RAJA Tutorials Repo</a> which we use
when we give in-person or virtual online tutorials in various venues. The
presentations complement the material found here. The tutorial material
evolves as we add new features to RAJA, so refer to it periodically if you
are interested in learning about new things in RAJA.</p>
<p>To understand the GPU examples (e.g., CUDA), it is also important to know the
difference between CPU (host) and GPU (device) memory allocations and how
transfers between those memory spaces work. For a detailed discussion, see
<a class="reference external" href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory">Device Memory</a>.</p>
<p>It is important to note that RAJA does not provide a memory model. This is by
design as application developers who use RAJA prefer to manage memory
in different ways. Thus, users are responsible for ensuring that data is
properly allocated and initialized on a GPU device when running GPU code.
This can be done using explicit host and device allocation and copying between
host and device memory spaces or via unified memory (UM), if available.
The RAJA Portability Suite contains other libraries, namely
<a class="reference external" href="https://github.com/LLNL/CHAI">CHAI</a> and
<a class="reference external" href="https://github.com/LLNL/Umpire">Umpire</a>, that complement RAJA by
providing alternatives to manual programming model specific memory operations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Most of the CUDA GPU exercises use unified memory (UM) via a simple
memory manager capability provided in a file in the <code class="docutils literal notranslate"><span class="pre">RAJA/exercises</span></code>
directory. HIP GPU exercises use explicit host and device memory
allocations and explicit memory copy operations to move data between
the two.</p>
</div>
</section>
<section id="a-little-c-background">
<span id="tutorial-lambda-label"></span><h2>A Little C++ Background<a class="headerlink" href="#a-little-c-background" title="Permalink to this headline">Â¶</a></h2>
<p>To understand the discussion and code examples, a working knowledge of C++
templates and lambda expressions is required. So, before we begin, we provide
a bit of background discussion of basic aspects of how RAJA use employs C++
templates and lambda expressions, which is essential to use RAJA successfully.</p>
<p>RAJA is almost an entirely header-only library that makes heavy use of
C++ templates. Using RAJA most easily and effectively is done by representing
the bodies of loop kernels as C++ lambda expressions. Alternatively, C++
functors can be used, but they make application source code more complex,
potentially placing a significant negative burden on source code readability
and maintainability.</p>
<section id="c-templates">
<h3>C++ Templates<a class="headerlink" href="#c-templates" title="Permalink to this headline">Â¶</a></h3>
<p>C++ templates enable one to write type-generic code and have the compiler
generate an implementation for each set of template parameter types specified.
For example, the <code class="docutils literal notranslate"><span class="pre">RAJA::forall</span></code> method to execute loop kernels is
essentially method defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">ExecPol</span><span class="p">,</span>
          <span class="n">typename</span> <span class="n">IdxType</span><span class="p">,</span>
          <span class="n">typename</span> <span class="n">LoopBody</span><span class="o">&gt;</span>
<span class="n">forall</span><span class="p">(</span><span class="n">IdxType</span><span class="o">&amp;&amp;</span> <span class="n">idx</span><span class="p">,</span> <span class="n">LoopBody</span><span class="o">&amp;&amp;</span> <span class="n">body</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, âExecPolâ, âIdxTypeâ, and âLoopBodyâ are C++ types that a user specifies
in her code and which are seen by the compiler when the code is built.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RAJA</span><span class="p">::</span><span class="n">forall</span><span class="o">&lt;</span> <span class="n">RAJA</span><span class="p">::</span><span class="n">loop_exec</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">RAJA</span><span class="p">::</span><span class="n">TypedRangeSegment</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="nb">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">});</span>
</pre></div>
</div>
<p>is a sequential CPU RAJA kernel that performs an element-by-element vector sum.
The C-style analogue of this kernel is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The execution policy type <code class="docutils literal notranslate"><span class="pre">RAJA::loop_exec</span></code> template argument
is used to choose as specific implementation of the
<code class="docutils literal notranslate"><span class="pre">RAJA::forall</span></code> method. The <code class="docutils literal notranslate"><span class="pre">IdxType</span></code> and <code class="docutils literal notranslate"><span class="pre">LoopBody</span></code> types are deduced by
the compiler based the arguments passed to the <code class="docutils literal notranslate"><span class="pre">RAJA::forall</span></code> method;
i.e., the <code class="docutils literal notranslate"><span class="pre">IdxType</span></code> is the stride-1 index range:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RAJA</span><span class="p">::</span><span class="n">TypedRangeSegment</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
<p>and the <code class="docutils literal notranslate"><span class="pre">LoopBody</span></code> type is the lambda expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="nb">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>
</pre></div>
</div>
</section>
<section id="elements-of-c-lambda-expressions">
<h3>Elements of C++ Lambda Expressions<a class="headerlink" href="#elements-of-c-lambda-expressions" title="Permalink to this headline">Â¶</a></h3>
<p>Here, we provide a brief description of the basic elements of C++ lambda
expressions. A more technical and detailed discussion is available here:
<a class="reference external" href="https://www.cprogramming.com/c++11/c++11-lambda-closures.html">Lambda Functions in C++11 - the Definitive Guide</a></p>
<p>Lambda expressions were introduced in C++ 11 to provide a lexical-scoped
name binding; specifically, a <em>closure</em> that stores a function with a data
environment. That is, a lambda expression can <em>capture</em> variables from an
enclosing scope for use within the local scope of the function expression.</p>
<p>A C++ lambda expression has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">capture</span> <span class="nb">list</span><span class="p">]</span> <span class="p">(</span><span class="n">parameter</span> <span class="nb">list</span><span class="p">)</span> <span class="p">{</span><span class="n">function</span> <span class="n">body</span><span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">capture</span> <span class="pre">list</span></code> specifies how variables outside the lambda scope are pulled
into the lambda data environment. The <code class="docutils literal notranslate"><span class="pre">parameter</span> <span class="pre">list</span></code> defines arguments
passed to the lambda function body â for the most part, lambda arguments
are just like arguments in a regular C++ method. Variables in the capture list
are initialized when the lambda expression is created, while those in the
parameter list are set when the lambda expression is called. The body of a
lambda expression is similar to the body of an ordinary C++ method.
RAJA kernel execution templates, such as <code class="docutils literal notranslate"><span class="pre">RAJA::forall</span></code> and <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code>
that we will describe in detail later, pass arguments
to lambdas based on usage and context such as loop iteration indices.</p>
<p>A C++ lambda expression can capture variables in the capture list <em>by value</em>
or <em>by reference</em>. This is similar to how arguments to C++ methods are passed;
i.e., <em>pass-by-reference</em> or <em>pass-by-value</em>. However, there are some subtle
differences between lambda variable capture rules and those for ordinary
methods. <strong>Variables included in the capture list with no extra symbols are
captured by value.</strong> Variables captured by value are effectively <em>const</em>
inside the lambda expression body and cannot be written to.
Capture-by-reference is accomplished by using the reference symbol â&amp;â before
the variable name similar to C++ method arguments.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">x</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">[</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">](){</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
</pre></div>
</div>
<p>generates a lambda expression that captures both âxâ and âyâ by reference
and assigns the value of âyâ to âxâ when called. The same outcome would be
achieved by writing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">&amp;</span><span class="p">](){</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>   <span class="o">//</span> <span class="n">capture</span> <span class="nb">all</span> <span class="k">lambda</span> <span class="n">arguments</span> <span class="n">by</span> <span class="n">reference</span><span class="o">...</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">](){</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>  <span class="o">//</span> <span class="n">capture</span> <span class="s1">&#39;x&#39;</span> <span class="n">by</span> <span class="n">reference</span> <span class="ow">and</span> <span class="s1">&#39;y&#39;</span> <span class="n">by</span> <span class="n">value</span><span class="o">...</span>
</pre></div>
</div>
<p>Note that the following two attempts will generate compilation errors:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">=</span><span class="p">](){</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>      <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="nb">all</span> <span class="k">lambda</span> <span class="n">arguments</span> <span class="n">captured</span> <span class="n">by</span> <span class="n">value</span><span class="p">,</span>
                      <span class="o">//</span>        <span class="n">so</span> <span class="n">cannot</span> <span class="n">assign</span> <span class="n">to</span> <span class="s1">&#39;x&#39;</span><span class="o">.</span>
<span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">](){</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>  <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">assign</span> <span class="n">to</span> <span class="s1">&#39;x&#39;</span> <span class="n">since</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">captured</span>
                      <span class="o">//</span>        <span class="n">by</span> <span class="n">value</span><span class="o">.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A variable that is captured by value in a lambda expression is
<strong>read-only.</strong></p>
</div>
</section>
<section id="a-few-notes-about-lambda-usage-with-raja">
<h3>A Few Notes About Lambda Usage With RAJA<a class="headerlink" href="#a-few-notes-about-lambda-usage-with-raja" title="Permalink to this headline">Â¶</a></h3>
<p>There are several issues to note about using C++ lambda expressions to
represent kernel bodies with RAJA. We describe them here.</p>
<blockquote>
<div><ul>
<li><p><strong>Prefer by-value lambda capture.</strong></p>
<p>We recommend <cite>capture by-value</cite> for all lambda kernel bodies passed to
RAJA execution methods. To execute a RAJA loop on a non-CPU device, such
as a GPU, all variables accessed in the loop body must be passed into the
GPU device data environment. Using capture by-value for all RAJA-based
lambda usage will allow your code to be portable for either CPU or GPU
execution. In addition, the read-only nature of variables captured
by-value can help avoid incorrect CPU code since the compiler will report
incorrect usage.</p>
</li>
</ul>
</div></blockquote>
<p><br /></p>
<blockquote>
<div><ul>
<li><p><strong>The â__device__â annotation is required for device execution using CUDA or HIP.</strong></p>
<p>Any lambda passed to a CUDA or HIP execution context (or function called from a
device kernel, for that matter) must be decorated with
the <code class="docutils literal notranslate"><span class="pre">__device__</span></code> annotation; for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RAJA</span><span class="p">::</span><span class="n">forall</span><span class="o">&lt;</span><span class="n">RAJA</span><span class="p">::</span><span class="n">cuda_exec</span><span class="o">&lt;</span><span class="n">BLOCK_SIZE</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="nb">range</span><span class="p">,</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="n">__device__</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="p">);</span>
</pre></div>
</div>
<p>Without this, the code will not compile and generate compiler errors
indicating that a âhostâ lambda cannot be called in âdeviceâ code.</p>
<p>RAJA provides the macro <code class="docutils literal notranslate"><span class="pre">RAJA_DEVICE</span></code> that can be used to help switch
between host-only or device-only compilation.</p>
</li>
</ul>
</div></blockquote>
<p><br /></p>
<blockquote>
<div><ul>
<li><p><strong>Use âhost-deviceâ annotation on a lambda carefully.</strong></p>
<p>RAJA provides the macro <code class="docutils literal notranslate"><span class="pre">RAJA_HOST_DEVICE</span></code> to support the dual
annotation <code class="docutils literal notranslate"><span class="pre">__</span> <span class="pre">host__</span> <span class="pre">__device__</span></code>, which makes a lambda or function
callable from CPU or GPU device code. However, when CPU performance is
important, <strong>the host-device annotation should be applied carefully on a
lambda that is used in a host (i.e., CPU) execution context</strong>. Although
compiler improvements in recent years have significantly
improved support for host-device lambda expressions, a loop kernel
containing a lambda annotated in this way may run noticeably slower on
a CPU than the same lambda with no annotation depending on the version of
the compiler (e.g., nvcc) you are using. To be sure that your code does not
suffer in performance, we recommend comparing CPU execution timings of
important kernels with and without the <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> annotation.</p>
</li>
</ul>
</div></blockquote>
<p><br /></p>
<blockquote>
<div><ul>
<li><p><strong>Cannot use âbreakâ and âcontinueâ statements in a lambda.</strong></p>
<p>In this regard, a lambda expression is similar to a function. So, if you
have loops in your code with these statements, they should be rewritten.</p>
</li>
</ul>
</div></blockquote>
<p><br /></p>
<blockquote>
<div><ul>
<li><p><strong>Global variables are not captured in a lambda.</strong></p>
<p>This fact is due to the C++ standard. If you need access to a
global variable inside a lambda expression, one solution is to make a local
reference to it; for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span><span class="o">&amp;</span> <span class="n">ref_to_global_val</span> <span class="o">=</span> <span class="n">global_val</span><span class="p">;</span>

<span class="n">RAJA</span><span class="p">::</span><span class="n">forall</span><span class="o">&lt;</span><span class="n">RAJA</span><span class="p">::</span><span class="n">cuda_exec</span><span class="o">&lt;</span><span class="n">BLOCK_SIZE</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="nb">range</span><span class="p">,</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="n">__device__</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">use</span> <span class="n">ref_to_global_val</span>
<span class="p">}</span> <span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p><br /></p>
<blockquote>
<div><ul>
<li><p><strong>Local stack arrays may not be captured by CUDA device lambdas.</strong></p>
<p>Although this is inconsistent with the C++ standard (local stack arrays
are properly captured in lambdas for code that will execute on a CPU),
attempting to access elements in a local stack array in a CUDA device
lambda may generate a compilation error depending on the version of the
device compiler you are using. One solution to this problem is to wrap the
array in a struct; for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">array_wrapper</span> <span class="p">{</span>
  <span class="nb">int</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="n">array</span><span class="p">;</span>
<span class="p">}</span> <span class="n">bounds</span><span class="p">;</span>

<span class="n">bounds</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span> <span class="p">};</span>

<span class="n">RAJA</span><span class="p">::</span><span class="n">forall</span><span class="o">&lt;</span><span class="n">RAJA</span><span class="p">::</span><span class="n">cuda_exec</span><span class="o">&lt;</span><span class="n">BLOCK_SIZE</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="n">__device__</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">access</span> <span class="n">entries</span> <span class="n">of</span> <span class="n">bounds</span><span class="o">.</span><span class="n">array</span>
<span class="p">}</span> <span class="p">);</span>
</pre></div>
</div>
<p>This issue was resolved in the 10.1 release of CUDA. If you are using an
earlier version, an implementation similar to the one above will be required.</p>
</li>
</ul>
</div></blockquote>
</section>
</section>
<section id="raja-examples-and-exercises">
<h2>RAJA Examples and Exercises<a class="headerlink" href="#raja-examples-and-exercises" title="Permalink to this headline">Â¶</a></h2>
<p>The remainder of this tutorial illustrates how to use RAJA features with
working code examples and interactive exercises. Files containing the
exercise source code are located in  the <code class="docutils literal notranslate"><span class="pre">RAJA/exercises</span></code> directory.
Additional information about the RAJA features used can be found
in <a class="reference internal" href="features.html#features-label"><span class="std std-ref">RAJA Features</span></a>.</p>
<p>The examples demonstrate CPU execution (sequential and OpenMP
multithreading) and GPU execution (CUDA and/or HIP). Examples that show how
to use RAJA with other parallel programming model back-ends will appear in
future RAJA releases. For adventurous users who wish to try experimental
RAJA back-end support, usage is similar to what is shown in the
examples here.</p>
<p>All RAJA programming model support features are enabled via CMake options,
which are described in <a class="reference internal" href="config_options.html#configopt-label"><span class="std std-ref">Build Configuration Options</span></a>.</p>
</section>
<section id="simple-loops-and-basic-raja-features">
<span id="tutorialbasic-label"></span><h2>Simple Loops and Basic RAJA Features<a class="headerlink" href="#simple-loops-and-basic-raja-features" title="Permalink to this headline">Â¶</a></h2>
<p>The examples in this section illustrate how to use <code class="docutils literal notranslate"><span class="pre">RAJA::forall</span></code> methods
to execute simple loop kernels; i.e., non-nested loops. It also describes
iteration spaces, reductions, atomic operations, scans, sorts, and RAJA
data views.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial/add_vectors.html">Basic Loop Execution: Vector Addition</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/indexset_segments.html">Iteration Spaces: Segments and IndexSets</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/vertexsum_coloring.html">Iteration Space Coloring: Mesh Vertex Sum</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/dot_product.html">Sum Reduction: Vector Dot Product</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/reductions.html">Reduction Types and Kernels with Multiple Reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/atomic_histogram.html">Atomic Operations: Computing a Histogram</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/scan.html">Parallel Scan Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/sort.html">Parallel Sort Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/view_layout.html">Data Views and Layouts</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/permuted-layout-batch-matrix-multiply.html">Permuted Layout: Batched Matrix-Multiplication</a></li>
</ul>
</div>
</section>
<section id="complex-loops-and-advanced-raja-features">
<span id="tutorialcomplex-label"></span><h2>Complex Loops and Advanced RAJA Features<a class="headerlink" href="#complex-loops-and-advanced-raja-features" title="Permalink to this headline">Â¶</a></h2>
<p>RAJA provides two APIs for writing complex kernels involving nested
loops: <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> that has been available for several years and
<code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code>, which is more recent and which will be moved out of
the <code class="docutils literal notranslate"><span class="pre">expt</span></code> namespace soon. We briefly introduce both interfaces here.
The tutorial sections that follow provide much more detailed descriptions.</p>
<p><code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> is analogous to <code class="docutils literal notranslate"><span class="pre">RAJA::forall</span></code> in that it involves
kernel execution templates, execution policies, iteration spaces, and lambda
expression kernel bodies. The main differences between <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> and
<code class="docutils literal notranslate"><span class="pre">RAJA::forall</span></code> are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> requires a tuple of iteration spaces, one for each level
in a loop nest, whereas <code class="docutils literal notranslate"><span class="pre">RAJA::forall</span></code> takes exactly one iteration
space.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> can accept multiple lambda expressions to express
different parts of a kernel body, whereas <code class="docutils literal notranslate"><span class="pre">RAJA::forall</span></code> accepts
exactly one lambda expression for a kernel body.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> execution policies are more complicated than those
for <code class="docutils literal notranslate"><span class="pre">RAJA::forall</span></code>. <code class="docutils literal notranslate"><span class="pre">RAJA::forall</span></code> policies essentially represent
the kernel execution back-end only. <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> execution policies
enable complex compile time algorithm transformations to be done without
changing the kernel code.</p></li>
</ul>
</div></blockquote>
<p>The following exercises illustrate the common usage of <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code>
and <code class="docutils literal notranslate"><span class="pre">``RAJA::expt::launch</span></code>. Please see <a class="reference internal" href="feature/policies.html#loop-elements-kernelpol-label"><span class="std std-ref">RAJA Kernel Execution Policies</span></a>
for more information about other execution policy constructs <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code>
provides. <code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code> takes a <code class="docutils literal notranslate"><span class="pre">RAJA::expt::Grid</span></code> type argument for
representing a teams-thread launch configuration, and a lambda expression
which takes a <code class="docutils literal notranslate"><span class="pre">RAJA::expt::LaunchContext</span></code> argument. <code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code>
allows an optional run time choice of execution environment, either CPU or GPU.
Code written inside the lambda expression body will execute in the chosen
execution environment. Within that environment, a user executes
kernel operations using <code class="docutils literal notranslate"><span class="pre">RAJA::expt::loop&lt;EXEC_POL&gt;</span></code> method calls, which
take lambda expressions to express loop body operations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A key difference between the <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> and
<code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code> approaches is that almost all of the
kernel execution pattern is expressed in the execution policy
when using <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code>, whereas with <code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code> the
kernel execution pattern is expressed mostly in the lambda
expression kernel body.</p>
</div>
<p>One may argue that <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> is more portable and flexible in that
the execution policy enables compile time code transformations without
changing kernel body code. On the other hand, <code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code> is
less opaque and more intuitive, but may require kernel body code changes for
algorithm changes. Which interface to use depends on personal preference
and other concerns, such as portability requirements, the need for run time
execution selection, etc. Kernel structure is more explicit in application
source code with <code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code>, and more concise and arguably more
opaque with <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code>. There is a large overlap of algorithms that can
be expressed with either interface. However, there are things that one can do
with one or the other but not both.</p>
<p>In the following sections, we introduce the basic mechanics and features
of both APIs with examples and exercises. We also present a sequence of
execution policy examples and matrix transpose examples using both
<code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> and <code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code> to compare and contrast the
two interfaces.</p>
</section>
<section id="nested-loops-with-raja-kernel">
<h2>Nested Loops with <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code><a class="headerlink" href="#nested-loops-with-raja-kernel" title="Permalink to this headline">Â¶</a></h2>
<p>The examples in this section illustrate various features of the
<code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> API used to execute nested loop kernels. It describes how to
construct kernel execution policies and use different view types and tiling
mechanisms to transform loop patterns. More information can be found in
<a class="reference internal" href="feature/loop_basic.html#loop-elements-kernel-label"><span class="std std-ref">Complex Loops (RAJA::kernel)</span></a>.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial/kernel_nested_loop_reorder.html">Basic <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> Mechanics and Nested Loop Ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/kernel_exec_pols.html"><code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> Execution Policies</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/offset-layout-5pt-stencil.html">OffsetLayout: Five-point Stencil</a></li>
</ul>
</div>
</section>
<section id="nested-loops-with-raja-expt-launch">
<h2>Nested Loops with <code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code><a class="headerlink" href="#nested-loops-with-raja-expt-launch" title="Permalink to this headline">Â¶</a></h2>
<p>The examples in this section illustrate how to use <code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code>
to create an run time selectable execution space for expressing algorithms
as nested loops.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial/launch_basic.html"><code class="docutils literal notranslate"><span class="pre">RAJA::expt::Launch</span></code> Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/launch_exec_pols.html"><code class="docutils literal notranslate"><span class="pre">RAJA::expt::Launch</span></code> Execution Policies</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/launch_naming_kernels.html">Naming kernels for NVTX/ROCTX tools</a></li>
</ul>
</div>
</section>
<section id="comparing-raja-kernel-and-raja-expt-launch-matrix-transpose">
<span id="tutorialmatrixtranspose-label"></span><h2>Comparing <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> and <code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code>: Matrix-Transpose<a class="headerlink" href="#comparing-raja-kernel-and-raja-expt-launch-matrix-transpose" title="Permalink to this headline">Â¶</a></h2>
<p>In this section, we compare <code class="docutils literal notranslate"><span class="pre">RAJA::kernel</span></code> and <code class="docutils literal notranslate"><span class="pre">RAJA::expt::launch</span></code>
implementations of a matrix transpose algorithm. We illustrate
implementation differences of the two interfaces as we build upon each
example with more complex features.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial/matrix_transpose.html">Matrix Transpose</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/matrix_transpose_tiled.html">Tiled Matrix Transpose</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/matrix_transpose_local_array.html">Tiled Matrix Transpose with Local Array</a></li>
</ul>
</div>
</section>
<section id="other-raja-features-and-usage-examples">
<h2>Other RAJA Features and Usage Examples<a class="headerlink" href="#other-raja-features-and-usage-examples" title="Permalink to this headline">Â¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial/halo-exchange.html">Workgroup Constructs: Halo Exchange</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/matrix_multiply.html">Matrix Multiplication: RAJA::kernel</a></li>
</ul>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="app_considerations.html" class="btn btn-neutral float-left" title="Application Considerations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tutorial/add_vectors.html" class="btn btn-neutral float-right" title="Basic Loop Execution: Vector Addition" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2022, Lawrence Livermore National Security, LLNS.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>